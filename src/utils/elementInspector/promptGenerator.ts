/**
 * Claude Prompt Generator
 * Generates well-formatted markdown prompts for Claude based on
 * selected elements and user descriptions.
 */

import type { InspectedElement, PromptGenerationOptions, ExtractedStyles } from '@/types/elementInspector';

const DEFAULT_OPTIONS: PromptGenerationOptions = {
  includeStyles: true,
  includeSourceGuesses: true,
  maxTextContentLength: 100,
};

/**
 * Generate a Claude-ready prompt from inspection data
 */
export function generateClaudePrompt(
  selectedElements: InspectedElement[],
  problemDescription: string,
  desiredChange: string,
  options: Partial<PromptGenerationOptions> = {}
): string {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const sections: string[] = [];

  // Header
  sections.push('# UI Issue Report\n');

  // Problem Description
  sections.push('## Problem Description\n');
  sections.push(problemDescription || '*No description provided*');
  sections.push('');

  // Desired Change
  sections.push('## Desired Change\n');
  sections.push(desiredChange || '*No desired change specified*');
  sections.push('');

  // Selected Elements
  sections.push('## Affected Elements\n');

  if (selectedElements.length === 0) {
    sections.push('*No elements selected*\n');
  } else {
    selectedElements.forEach((element, index) => {
      sections.push(formatElementSection(element, index + 1, opts));
    });
  }

  // Source File Hints
  if (opts.includeSourceGuesses && selectedElements.some(el => el.guessedSourceFiles.length > 0)) {
    sections.push('## Likely Source Files\n');

    const allGuesses = new Set<string>();
    selectedElements.forEach(el => {
      el.guessedSourceFiles.forEach(guess => allGuesses.add(guess));
    });

    Array.from(allGuesses).slice(0, 8).forEach(file => {
      sections.push(`- \`${file}\``);
    });
    sections.push('');
  }

  // Context for Claude
  sections.push('## Additional Context\n');
  sections.push('- This is a Next.js/React application using TypeScript');
  sections.push('- Styling is done with Tailwind CSS');
  sections.push('- Components are located in `src/components/`');
  sections.push('');

  // Footer
  sections.push('---');
  sections.push('*Generated by Visual Element Inspector*');

  return sections.join('\n');
}

/**
 * Format a single element as a markdown section
 */
function formatElementSection(
  element: InspectedElement,
  index: number,
  options: PromptGenerationOptions
): string {
  const lines: string[] = [];

  lines.push(`### Element ${index}: ${element.displayName}\n`);

  // Selector Path
  lines.push('**Selector Path:**');
  lines.push('```css');
  lines.push(element.selectorPath);
  lines.push('```\n');

  // Component name
  if (element.reactComponentName) {
    lines.push(`**React Component:** \`${element.reactComponentName}\`\n`);
  }

  // Tag and classes
  lines.push(`**Tag:** \`<${element.tagName}>\``);
  if (element.classNames.length > 0) {
    lines.push(`**Classes:** \`${element.classNames.join(' ')}\``);
  }
  lines.push('');

  // Text content
  if (element.textContent) {
    const truncated = element.textContent.length > options.maxTextContentLength
      ? element.textContent.slice(0, options.maxTextContentLength) + '...'
      : element.textContent;
    lines.push(`**Text Content:** "${truncated}"\n`);
  }

  // Computed styles
  if (options.includeStyles) {
    lines.push('**Computed Styles:**');
    lines.push('```css');
    lines.push(formatStylesForPrompt(element.computedStyles));
    lines.push('```\n');
  }

  // Dimensions
  lines.push(`**Dimensions:** ${Math.round(element.boundingRect.width)}px Ã— ${Math.round(element.boundingRect.height)}px\n`);

  return lines.join('\n');
}

/**
 * Format extracted styles as readable CSS-like text
 */
function formatStylesForPrompt(styles: ExtractedStyles): string {
  const lines: string[] = [];

  if (styles.display !== 'block') lines.push(`display: ${styles.display};`);
  if (styles.position !== 'static') lines.push(`position: ${styles.position};`);
  lines.push(`width: ${styles.width};`);
  lines.push(`height: ${styles.height};`);

  if (styles.margin !== '0px') lines.push(`margin: ${styles.margin};`);
  if (styles.padding !== '0px') lines.push(`padding: ${styles.padding};`);

  lines.push(`font-size: ${styles.fontSize};`);
  if (styles.fontWeight !== '400') lines.push(`font-weight: ${styles.fontWeight};`);
  lines.push(`color: ${styles.color};`);

  if (styles.backgroundColor !== 'transparent') {
    lines.push(`background-color: ${styles.backgroundColor};`);
  }
  if (styles.border !== 'none') lines.push(`border: ${styles.border};`);
  if (styles.borderRadius !== '0px') lines.push(`border-radius: ${styles.borderRadius};`);

  // Flexbox properties
  if (styles.flexDirection) lines.push(`flex-direction: ${styles.flexDirection};`);
  if (styles.justifyContent) lines.push(`justify-content: ${styles.justifyContent};`);
  if (styles.alignItems) lines.push(`align-items: ${styles.alignItems};`);
  if (styles.gap && styles.gap !== 'normal') lines.push(`gap: ${styles.gap};`);

  return lines.join('\n');
}
